# 4. 语法分析

## 4.1 引论

### 语法分析器的作用

![image-20230515133747236](C:\Users\仵六七\AppData\Roaming\Typora\typora-user-images\image-20230515133747236.png)



## 4.2 上下文无关文法

### 1. 概念

--由终结符、非终结符、开始符号和产生式组成--

* 由文法的开始符号经过**零步或多步**推导产生的文法符号序列是**句型**
* 由文法的开始符号经过**单步或者多步**推导产生的文法符号序列是**句子**
* ⭕句子是不含非终结符的句型

### 2. 推导

* 最左推导：每一步都代替最左非终结符。（推导出的句型称为**左句型**）
* 最右推导（规范推导）：每一步都代替最右非终结符

### 3. 分析树

​	即推导的图形化表示，不能显示出替代顺序的选择。

### 4. 二义性

* 概念：L(G)中存在一个具有两个或两个以上最左（或最右）推导的句子，则G是二义性文法
* 不止一颗分析树

### 5. 上下文无关文法和正规表达式

* 正规表达式所描述的每一种结构都可以用上下文无关文法来描述。反之不然。

* 正规表达式  ——NFA---> 上下文无关文法

  ①对于NFA的每个状态i，创建一个非终结符A<sub>i</sub>

  ②状态i有一个在输入a（ε）上到达状态j的转换，则加入产生式A<sub>i</sub>->aA<sub>j</sub>（A<sub>i</sub>->A<sub>j</sub>）

  ③如果i是接收状态，加入产生式A<sub>i</sub>->ε

  ④如果i是开始状态，令A<sub>i</sub>为所得文法的开始符号

## 4.3 设计文法

### 1. 消除二义性

* 有二义性<->有多个分析树

### 2. 消除左递归（引入新的非终结符A’）

- 左递归：

  - 直接左递归：A->Aα

  - 间接左递归：A->Bβ，B->Aα

- 消除左递归：

  - 套公式

    A—>Aα|β ==> A—>βA‘ 、A'—>αA’|ε

### 3. 提取左因子

​	A->ab<sub>1</sub>|ab<sub>2</sub>

​		↓

​	A->aA'

​	A'->b<sub>1</sub>|b<sub>2</sub>

## 4.4 自顶向下语法分析

### 1. 主旨

从根节点出发，**自上而下、从左到右**的为输入串建立一颗分析树。即为输入串寻找最左推导。

##### 问题：

左递归会陷入死循环、会产生回溯问题

##### 解决：

死循环：消除左递归；回溯：提取左因子

### 2. 递归下降子程序分析法

​	每一个非终结符都对应一个分析过程，从开始符号开始递归分析。

<img src="C:\Users\仵六七\AppData\Roaming\Typora\typora-user-images\image-20230515180615527.png" alt="image-20230515180615527" style="zoom: 50%;" />

### 3. 非递归的预测分析法(表驱动的预测分析方法)

* 模型

  <img src="C:\Users\仵六七\AppData\Roaming\Typora\typora-user-images\image-20230515174557371.png" alt="image-20230515174557371" style="zoom:50%;" />

* 输入缓冲区：包含要分析的串，后面跟结束标记“$”

* 栈：存放文法符号序列，栈底符号“$”。初始状态只含有文法的开始符号和栈底“$”

* 分析表：一个二维数组M[A,a]，a是终结符或$，A是非终结符

* 输出流：假设只是打印出所用产生式

##### 输入

串w和文法G的预测分析表M

##### 输出

w的最左推导（w属于G）或是报告错误

<img src="C:\Users\仵六七\AppData\Roaming\Typora\typora-user-images\image-20230515190707457.png" alt="image-20230515190707457" style="zoom:50%;" />

### 4. FIRST集和FOLLOW集

**FIRST(α)：**

* 如果α是任意的文法符号串，定义FIRST(α)是从α推导出的串的首终结符集合。即`FIRST(α)={a|α=>a...，a是终结符}`
* 若α=>ε，规定ε∈FIRST(α)
* “由α导出的串的首终结符集合”
* <img src="C:\Users\仵六七\AppData\Roaming\Typora\typora-user-images\image-20230530112551871.png" alt="image-20230530112551871" style="zoom: 67%;" />

**FOLLOW(A)**

* A是一个非终结符，定义FLOLLOW(A)是包含所有在句型中紧跟在A后面的终结符a的集合。即`FOLLOW(A)={a|S==>α Aaβ，a是终结符，α、β是文法符号}`
* “紧跟在A后面的a的集合”
* ![image-20230530113521459](C:\Users\仵六七\AppData\Roaming\Typora\typora-user-images\image-20230530113521459.png)

### 5.构建预测分析表 

* 输入：文法G

* 输出：分析表M

* 方法：
  1. 对文法的每个产生式A—>α执行2和3
  2. 对FIRST(α)中的每个终结符a，将A—>α加入到M[A,α]
  3. 如果ε在FIRST(α)中，对FOLLOW(A)的每个终结符b(包括$)，把A—>α加入M[A,b]
  4. 将M中每个没有定义的表项都置为error

### 6. LL(1)文法

分析表中没有多重定义表项的文法叫做LL(1)文法。

​	L：一个表示从左到右扫描输入，一个表示产生最左推导

​	(1):表示每步向前扫描一个输入字符

*特性：

* 不是二义性
* 不含有左递归

### 7. 预测分析的错误恢复

#### 发现错误

* 栈顶的非终结符和下一个输入符号不匹配
* 栈顶是非终结符A，输入符号是a，而M[A,a]是error

#### 错误恢复

1. 采用恐慌模式的错误恢复

   分析器每次抛弃一个输入记号，直到输入记号属于某个指定的同步记号集合
   
2. 短语层次错误恢复

   预测分析表的空白条目中填写指向处理例程的指针

## 4.5 自底向上语法分析

### 1. 主旨

从输入串开始，逐步进行规约，直至规约到文法的开始符号。

### 2. 规约（句柄剪枝）

* 匹配产生式

### 3. 移进-规约语法分析技术

#### 	四种状态

* 移进：把下一个输入符号移进栈中
* 规约：语法分析器在栈中确定句柄的左端，并选择正确的非终结符替代句柄
* 接受：宣告分析成功
* 出错：发现错误并调用错误恢复程序进行错误处理

### 4.移进-规约的冲突

* 根据栈中的内容不能决定是移进还是规约（移进-规约冲突）
* 不能决定按哪一个产生式进行规约（规约-规约冲突）

## 4.6 LR语法分析器

### 1. LR分析器

* 分析表
  * ACTION(s,a)：当状态ｓ面临输入ａ时的动作（移进、规约、接受、出错）
  * GOTO(s,X)：表示面对非终结符Ｘ的下一状态。实际上是识别文法活前缀的DFA的转换函数.

### 2. LR分析程序

* 实质：分析栈+DFA

* LR分析算法

  * 输入：文法G的LR分析表和输入串w

  * 输出：如果w属于L(G)，则输出w的自底向上分析,否则报错

  * 方法：首先把初始状态s0放在栈顶，把w$放在输入缓冲区，然后执行如下程序:

    ```c++
    令ip指向w$的第一个符号;
    repeat forever begin
    	令s是栈顶的状态,a是ip所指的符号;
    	if action[s,a]="移进s'" then begin
    		把a和s'依次压入栈顶;
    		让ip指向下一个输入符号
    	end
    	else if action[s,a]="按产生式A->β规约",then begin
    		从栈顶弹出2*|β|个符号;
    		令s'是现在的栈顶状态;
    		把A和goto[s',A]压入栈;
    		输出产生式A->β
    	end
    	else if action[s,a]="接受" then
    		return
    	else error()
    end
    ```

* LR分析器的性质

  * 栈内符号串和扫描剩下的输入符号串构成了一个规范句型
  * 一旦栈的顶部出现可规约串(句柄)，则进行规约

#### 字的前缀、活前缀

* 前缀：字的任意部首
* 活前缀：规范句型的一个前缀，这种前缀不含句柄之后的任何符号。

### 3. LR文法

给定文法G，如果能为G构建出LR语法分析表，则称G是LR文法。

### 4. SLR语法分析表的构建

#### LR(0)项目

* 指在G的产生式右部的某处加点的产生式

#### 拓广文法

* G的拓广文法G'是在G的基础上增加一个新的开始符号S'和产生式S'->S。
* 目的是用来指示语法分析器什么时候应该停止分析并宣布接受输入。

#### 闭包运算closure

* <img src="C:\Users\仵六七\AppData\Roaming\Typora\typora-user-images\image-20230606084635712.png" alt="image-20230606084635712" style="zoom: 67%;" />

* 核心项目：初始项S'->·S和所有点不在左端的项目

  非核心项：点在左端的非初始项

#### GOTO函数

goto(I,X)：将I中在X左边的点全部移到X右边，再求它的闭包

#### 项目集族的构造

* C={I<sub>0</sub>，I<sub>1</sub>，I<sub>2</sub>，…，I<sub>n</sub>}
* 1. 先求closure({S'->·S})=I<sub>0</sub>
  2. 对I<sub>0</sub>，求goto(I<sub>0</sub>,X)

#### SLR语法分析表

* 输入：拓广文法G'
* 输出：G'的SLR语法分析表函数action和goto
* 方法：
  1. 构造C={I<sub>0</sub>，I<sub>1</sub>，I<sub>2</sub>，…，I<sub>n</sub>}，即G'的LR(0)项目集规范族

# 五、语法制导翻译

## 5.1 语法制导定义(SDD)

* 语法制导定义是一个上下文无关文法和属性及规则的集合，其中属性和文法符号相关联，规则和产生式相关联。

### 继承属性和综合属性

* 节点N的**综合属性**是由N上的产生式所关联的语义规则来定义。是通过分析树中*其子节点或本身*的属性值计算出来的。
* **继承属性**是由N的父节点上的产生式所关联的语义规则来定义。是由该节点的*兄弟节点、父节点及其本身*的属性值计算出来的。
* 每个节点都带有属性值的分析树称为**注释分析树**
* 一个没有副作用的SDD称为**属性文法**

## 5.2 SDD求值顺序

### 依赖图

* 表达分析树中各节点的继承属性和综合属性间的依赖关系的有向图

### 计算顺序

* 拓扑排序：若m->n是从m到n的边，那么在此排序中m先于n

### S属性的定义

* 一个只包含综合属性的SDD称为**S属性的SDD**。
* S属性的SDD可以按照分析树节点的任何自底向上顺序计算各个属性的值，并可以在自底向上的语法分析过程中实现

### L属性的定义

* 在一个产生式体所关联的各个属性之间，依赖图的边总是从左到右，而不能从右到左
* 对每个产生式，其每个语义规则中的每个属性要么是综合属性，要么是Xj的一个继承属性。

^^S属性文法∈L属性文法

## 5.3 语法制导翻译的应用

### 语法树的构造

* Node（op，left，right）：用来建立标记为op的运算符结点
* Leaf（op，val）：建立一个叶子结点

### 翻译方案

* 语义规则：给出了属性计算的定义，没有属性计算的次序
* 翻译模式：给出使用语义规则进行计算的次序，把实现细节表示出来

## 5.4 语法制导的翻译方案（SDT）

* 是语法制导定义的一种补充，是在产生式体中嵌入了程序片段的一个上下文无关文法
* 语义动作用{ }包起来

### 后缀翻译方案

* 所有动作都在产生式最右端的SDT

### 产生式内部带有语义动作的SDT

### 从翻译模式中消除左递归

# 六、中间代码生成

## 6.1 中间代码表示方式

### 后缀式

* E1 op E2  =>  E1 E2 op

### 图形化表示

* 语法树

  ![image-20230606155436495](C:\Users\仵六七\AppData\Roaming\Typora\typora-user-images\image-20230606155436495.png)

* DAG图

  ![image-20230606155520120](C:\Users\仵六七\AppData\Roaming\Typora\typora-user-images\image-20230606155520120.png)

  

## 6.2 三地址码的实现

* 三地址码是由`x:=y op z`形式的语句

  ![image-20230606161447016](C:\Users\仵六七\AppData\Roaming\Typora\typora-user-images\image-20230606161447016.png)

  ### 四元式

  带有四个域的记录结构，这四个域分别为op、arg1、arg2、及result。如下图（a）所示

  * 跟符号表有关。arg1、arg2及result域的内容通常是指向这些域所代表的名字在符号表表项的指针。临时变量生成时一定要填入符号表

  ![image-20230606163859303](C:\Users\仵六七\AppData\Roaming\Typora\typora-user-images\image-20230606163859303.png)

  ### 三元式

  只需要三个域：op、arg1和arg2。如上图（b）所示

  * ![image-20230606164340417](C:\Users\仵六七\AppData\Roaming\Typora\typora-user-images\image-20230606164340417.png)

  ### 间接三元式

  另设一张指示器（称为间码表），它按运算的先后顺序列出有关三元式在三元式表中的位置。

  ![image-20230606164610403](C:\Users\仵六七\AppData\Roaming\Typora\typora-user-images\image-20230606164610403.png)

* 间码表用来表示代码使用顺序

## 6.3 布尔表达式与控制流

